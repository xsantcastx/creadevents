import { Component, inject, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router, RouterLink } from '@angular/router';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule, FormsModule } from '@angular/forms';
import { TranslateModule } from '@ngx-translate/core';
import { AuthService } from '../../../services/auth.service';
import { ProductsService } from '../../../services/products.service';
import { CategoryService } from '../../../services/category.service';
import { MaterialService } from '../../../services/material.service';
import { StorageService } from '../../../services/storage.service';
import { MediaService } from '../../../services/media.service';
import { Product } from '../../../models/product';
import { Category, Material, TemplateComposition } from '../../../models/catalog';
import { MediaCreateInput, MEDIA_VALIDATION } from '../../../models/media';
import { GalleryUploaderComponent } from '../../../shared/components/gallery-uploader/gallery-uploader.component';

interface CatalogOption {
  id: string;
  label: string;
  categoryId: string;
  materialId: string;
  familyId?: string;
  sizeHint?: string;
}

@Component({
  selector: 'app-products-admin',
  standalone: true,
  imports: [CommonModule, RouterLink, ReactiveFormsModule, FormsModule, TranslateModule, GalleryUploaderComponent],
  templateUrl: './products-admin.page.html',
  styleUrl: './products-admin.page.scss'
})
export class ProductsAdminComponent implements OnInit {
  private authService = inject(AuthService);
  private router = inject(Router);
  private fb = inject(FormBuilder);
  private productsService = inject(ProductsService);
  private categoryService = inject(CategoryService);
  private materialService = inject(MaterialService);
  private storageService = inject(StorageService);
  private mediaService = inject(MediaService);

  products: Product[] = [];
  categories: Category[] = [];
  materials: Material[] = [];

  catalogOptions: CatalogOption[] = [];
  filteredCatalogOptions: CatalogOption[] = [];
  catalogSearchTerm = '';
  selectedCatalogOption: CatalogOption | null = null;

  currentStep = 1;
  readonly maxStep = 3;
  readonly stepLabels: string[] = [
    'admin.step_select_product',
    'admin.step_content',
    'admin.step_media'
  ];

  isLoading = true;
  showModal = false;
  isEditMode = false;
  isSaving = false;
  isGenerating = false; // Loading state for template generation

  selectedProduct: Product | null = null;
  productForm: FormGroup;

  successMessage = '';
  errorMessage = '';
  searchTerm = '';
  selectedThickness: string = 'all';
  showDeleteConfirm = false;
  productToDelete: Product | null = null;

  // Image upload
  selectedCoverFile: File | null = null;
  coverPreview: string | null = null;
  galleryFiles: File[] = []; // DEPRECATED - use galleryMediaIds instead
  galleryMediaIds: string[] = []; // Media document IDs for gallery images
  uploadProgress: number = 0;
  isUploading = false;

  // Auto-fill preview
  autoFillPreview: TemplateComposition | null = null;
  autoGeneratedName = ''; // Auto-generated product name from material + category
  descriptionLocked = false;
  specsLocked = false;
  seoLocked = false;
  private isAutoFilling = false;
  private currentStatus: 'draft' | 'published' | 'archived' = 'draft';
  
  // Template availability warnings
  templateWarnings: string[] = [];
  showTemplateWarning = false;

  constructor() {
    this.productForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(3)]],
      categoryId: ['', [Validators.required]],
      materialId: ['', [Validators.required]],
      description: [''],
      seoTitle: [''],
      seoMeta: [''],
      price: ['', [Validators.min(0)]],
      stock: ['', [Validators.min(0)]],
      size: ['160√ó320cm', [Validators.required]],
      sku: [''],
      finish: ['Pulido'],
      usage: ['Cocinas, Ba√±os, Fachadas'], // Comma-separated
      active: [true]
    });
  }

  async ngOnInit() {
    await this.checkAdminAccess();
    await this.loadMasterData();
    await this.loadProducts();
    this.setupAutoFillListeners();
  }

  private async checkAdminAccess() {
    const user = this.authService.getCurrentUser();
    if (!user) {
      this.router.navigate(['/client/login']);
      return;
    }

    const isAdmin = await this.authService.isAdmin(user.uid);
    if (!isAdmin) {
      this.router.navigate(['/']);
      return;
    }
  }

  private async loadMasterData() {
    try {
      // Load categories and materials in parallel
      const [categories, materials] = await Promise.all([
        new Promise<Category[]>((resolve) => {
          this.categoryService.getActiveCategories().subscribe({
            next: (data) => {
              console.log('‚úÖ Categories loaded:', data.length, data);
              resolve(data);
            },
            error: (err) => {
              console.error('‚ùå Error loading categories:', err);
              resolve([]);
            }
          });
        }),
        new Promise<Material[]>((resolve) => {
          this.materialService.getActiveMaterials().subscribe({
            next: (data) => {
              console.log('‚úÖ Materials loaded:', data.length, data);
              resolve(data);
            },
            error: (err) => {
              console.error('‚ùå Error loading materials:', err);
              resolve([]);
            }
          });
        })
      ]);

      this.categories = categories;
      this.materials = materials;

      console.log('üìä Final counts - Categories:', this.categories.length, 'Materials:', this.materials.length);

      // Warn if data is missing
      if (this.categories.length === 0 || this.materials.length === 0) {
        console.warn('‚ö†Ô∏è Master data not found! Please run seed at /admin/seed');
        this.errorMessage = '‚ö†Ô∏è Categories or Materials not found. Please run seed first at /admin/seed';
      }

      this.buildCatalogOptions();
      this.applyCatalogFilter();
    } catch (error) {
      console.error('Error loading master data:', error);
      this.errorMessage = 'Failed to load categories/materials. Please run seed first.';
    }
  }

  private async loadProducts() {
    this.isLoading = true;
    try {
      this.productsService.getAllProducts().subscribe({
        next: (products) => {
          this.products = products;
          this.isLoading = false;
        },
        error: (error) => {
          console.error('Error loading products:', error);
          this.errorMessage = 'admin.error_occurred';
          this.isLoading = false;
        }
      });
    } catch (error) {
      console.error('Error loading products:', error);
      this.errorMessage = 'admin.error_occurred';
      this.isLoading = false;
    }
  }

  private buildCatalogOptions() {
    const options: CatalogOption[] = [];

    this.categories.forEach((category) => {
      this.materials.forEach((material) => {
        const id = `${category.id || category.slug}__${material.id || material.slug}`;
        const label = `${material.name} ‚Ä¢ ${category.name}`;
        const sizeHint = category.defaultSpecOverrides?.size;

        options.push({
          id,
          label,
          categoryId: category.id || category.slug,
          materialId: material.id || material.slug,
          sizeHint
        });
      });
    });

    this.catalogOptions = options.sort((a, b) => a.label.localeCompare(b.label));
    console.log('Built catalog options:', this.catalogOptions.length);
  }

  applyCatalogFilter(term: string = this.catalogSearchTerm) {
    const normalized = term.trim().toLowerCase();
    if (!normalized) {
      this.filteredCatalogOptions = [...this.catalogOptions];
      console.log('Showing all catalog options:', this.filteredCatalogOptions.length);
      return;
    }

    this.filteredCatalogOptions = this.catalogOptions.filter(option =>
      option.label.toLowerCase().includes(normalized)
    );
    console.log(`Filtered to ${this.filteredCatalogOptions.length} options for term: "${term}"`);
  }

  onCatalogSearch(value: string) {
    this.catalogSearchTerm = value;
    this.applyCatalogFilter(value);
  }

  selectCatalogOption(option: CatalogOption) {
    if (!option) {
      return;
    }
    this.selectedCatalogOption = option;

    this.productForm.patchValue({
      categoryId: option.categoryId,
      materialId: option.materialId,
      size: option.sizeHint || this.productForm.get('size')?.value
    });

    this.updateAutoGeneratedName();
    this.triggerAutoFill();
    this.goToStep(2);
  }

  goToStep(step: number) {
    if (step < 1 || step > this.maxStep) {
      return;
    }

    if (step > this.currentStep && !this.isStepValid(this.currentStep)) {
      this.errorMessage = 'admin.invalid_form';
      return;
    }

    this.currentStep = step;
  }

  nextStep() {
    this.goToStep(this.currentStep + 1);
  }

  previousStep() {
    this.goToStep(this.currentStep - 1);
  }

  private isStepValid(step: number): boolean {
    if (step === 1) {
      const categoryId = this.productForm.get('categoryId')?.value;
      const materialId = this.productForm.get('materialId')?.value;
      if (!categoryId || !materialId) {
        return false;
      }
    }

    if (step === 2) {
      if (this.productForm.get('name')?.invalid) {
        return false;
      }
    }

    return true;
  }

  /**
   * Setup form listeners for auto-fill functionality
   */
  private setupAutoFillListeners() {
    // Watch for changes in categoryId or materialId to auto-generate product name
    this.productForm.get('categoryId')?.valueChanges.subscribe(() => {
      this.updateAutoGeneratedName();
      this.triggerAutoFill();
    });
    this.productForm.get('materialId')?.valueChanges.subscribe(() => {
      this.updateAutoGeneratedName();
      this.triggerAutoFill();
    });
    this.productForm.get('usage')?.valueChanges.subscribe(() => this.triggerAutoFill());

    this.productForm.get('description')?.valueChanges.subscribe(() => {
      if (!this.isAutoFilling) {
        this.descriptionLocked = true;
      }
    });

    this.productForm.get('seoTitle')?.valueChanges.subscribe(() => {
      if (!this.isAutoFilling) {
        this.seoLocked = true;
      }
    });

    this.productForm.get('seoMeta')?.valueChanges.subscribe(() => {
      if (!this.isAutoFilling) {
        this.seoLocked = true;
      }
    });
  }

  /**
   * Update auto-generated product name when material or category changes
   */
  private updateAutoGeneratedName() {
    const categoryId = this.productForm.get('categoryId')?.value;
    const materialId = this.productForm.get('materialId')?.value;

    if (!categoryId || !materialId) {
      this.autoGeneratedName = '';
      this.productForm.patchValue({ name: '' }, { emitEvent: false });
      return;
    }

    const category = this.categories.find(c => c.id === categoryId);
    const material = this.materials.find(m => m.id === materialId);

    if (category && material) {
      if (this.selectedCatalogOption) {
        this.autoGeneratedName = this.selectedCatalogOption.label.replace(' ‚Ä¢ ', ' ');
      } else {
        // Generate name: "{Material} {Grosor}" (e.g., "Black Gold 12mm")
        this.autoGeneratedName = `${material.name} ${category.slug}`;
      }
      // Update form value silently (without triggering valueChanges)
      this.isAutoFilling = true;
      this.productForm.patchValue({ name: this.autoGeneratedName }, { emitEvent: false });
      this.isAutoFilling = false;
    }
  }

  /**
   * Trigger auto-fill when name, category, or material changes
   */
  async triggerAutoFill() {
    const name = this.productForm.get('name')?.value;
    const categoryId = this.productForm.get('categoryId')?.value;
    const materialId = this.productForm.get('materialId')?.value;

    // Reset warnings
    this.templateWarnings = [];
    this.showTemplateWarning = false;

    // Need all three to generate
    if (!name || !categoryId || !materialId) {
      this.autoFillPreview = null;
      return;
    }

    this.isGenerating = true;
    const previousAuto = this.isAutoFilling;
    this.isAutoFilling = true;

    try {
      // Get usage from form
      const usageStr = this.productForm.get('usage')?.value || 'Cocinas, Ba√±os, Fachadas';
      const usage = usageStr.split(',').map((u: string) => u.trim());

      // Generate auto-filled data
      const generated = await this.productsService.generateProductData({
        name,
        categoryId,
        materialId,
        usage,
        finish: this.productForm.get('finish')?.value
      } as any);

      this.autoFillPreview = generated;

      // Check for missing templates and add warnings
      if (!generated.description || generated.description.trim() === '') {
        this.templateWarnings.push('Description template not found - using default');
      }
      if (!generated.seoTitle || generated.seoTitle.trim() === '') {
        this.templateWarnings.push('SEO title template not found - using default');
      }
      if (!generated.seoMeta || generated.seoMeta.trim() === '') {
        this.templateWarnings.push('SEO meta description template not found - using default');
      }

      // Show warning if any templates are missing
      if (this.templateWarnings.length > 0) {
        this.showTemplateWarning = true;
      }

      // Auto-apply if not locked
      if (!this.descriptionLocked && generated.description) {
        this.productForm.patchValue({ description: generated.description }, { emitEvent: false });
      }
      if (!this.seoLocked) {
        if (generated.seoTitle) {
          this.productForm.patchValue({ seoTitle: generated.seoTitle }, { emitEvent: false });
        }
        if (generated.seoMeta) {
          this.productForm.patchValue({ seoMeta: generated.seoMeta }, { emitEvent: false });
        }
      }

    } catch (error) {
      console.error('Error generating auto-fill:', error);
      this.templateWarnings.push('Error loading templates - please check your configuration');
      this.showTemplateWarning = true;
    } finally {
      this.isGenerating = false;
      this.isAutoFilling = previousAuto;
    }
  }

  /**
   * Toggle description lock
   */
  toggleDescriptionLock() {
    this.descriptionLocked = !this.descriptionLocked;
  }

  /**
   * Toggle specs lock
   */
  toggleSpecsLock() {
    this.specsLocked = !this.specsLocked;
  }

  /**
   * Toggle SEO lock
   */
  toggleSeoLock() {
    this.seoLocked = !this.seoLocked;
  }

  get filteredProducts(): Product[] {
    let filtered = this.products;

    // Filter by search term
    if (this.searchTerm) {
      const term = this.searchTerm.toLowerCase();
      filtered = filtered.filter(p => 
        p.name.toLowerCase().includes(term) ||
        p.slug.toLowerCase().includes(term) ||
        (p.description && p.description.toLowerCase().includes(term))
      );
    }

    // Filter by thickness
    if (this.selectedThickness !== 'all') {
      filtered = filtered.filter(p => p.grosor === this.selectedThickness);
    }

    return filtered;
  }

  openCreateModal() {
    this.isEditMode = false;
    this.selectedProduct = null;
    this.autoFillPreview = null;
    this.descriptionLocked = false;
    this.seoLocked = false;
    this.currentStatus = 'draft';
    this.selectedCatalogOption = null;
    this.catalogSearchTerm = '';
    this.applyCatalogFilter('');
    this.currentStep = 1;
    
    this.productForm.reset({ 
      name: '',
      categoryId: '',
      materialId: '',
      description: '',
      seoTitle: '',
      seoMeta: '',
      size: '160√ó320cm',
      finish: 'Pulido',
      usage: 'Cocinas, Ba√±os, Fachadas',
      active: true
    });
    
    this.selectedCoverFile = null;
    this.coverPreview = null;
    this.galleryFiles = [];
    this.showModal = true;
    this.successMessage = '';
    this.errorMessage = '';
  }

  openEditModal(product: any) {
    this.isEditMode = true;
    this.selectedProduct = product;
    this.autoFillPreview = null;
    
    // Load lock states from product data (default to true if editing to preserve existing content)
    this.descriptionLocked = product.descriptionLocked !== undefined ? product.descriptionLocked : true;
    this.specsLocked = product.specsLocked !== undefined ? product.specsLocked : false;
    this.seoLocked = product.seoLocked !== undefined ? product.seoLocked : true;
    
    this.currentStatus = product.status || 'draft';
    this.currentStep = this.maxStep;
    
    const usageStr = product.specs?.usage?.join(', ') || 'Cocinas, Ba√±os, Fachadas';
    
    this.productForm.patchValue({
      name: product.name,
      categoryId: product.categoryId || '',
      materialId: product.materialId || '',
      description: product.description || '',
      seoTitle: product.seo?.title || '',
      seoMeta: product.seo?.metaDescription || '',
      price: product.price || '',
      stock: product.stock || '',
      size: product.specs?.size || product.size || '160√ó320cm',
      sku: product.sku || '',
      finish: product.specs?.finish || 'Pulido',
      usage: usageStr,
      active: product.active !== false
    });
    
    this.selectedCoverFile = null;
    this.coverPreview = product.coverImage || product.imageUrl || null;
    this.galleryFiles = [];
    this.galleryMediaIds = product.galleryImageIds || [];
    this.showModal = true;
    this.successMessage = '';
    this.errorMessage = '';
  }

  closeModal() {
    this.showModal = false;
    this.productForm.reset();
    this.selectedProduct = null;
    if (this.coverPreview && this.coverPreview.startsWith('blob:')) {
      URL.revokeObjectURL(this.coverPreview);
    }
    this.selectedCoverFile = null;
    this.coverPreview = null;
    this.galleryFiles = [];
    this.galleryMediaIds = [];
    this.uploadProgress = 0;
    this.autoFillPreview = null;
    this.descriptionLocked = false;
    this.specsLocked = false;
    this.seoLocked = false;
    this.currentStep = 1;
  }

  async onCoverSelected(event: Event) {
    const input = event.target as HTMLInputElement;
    if (!input.files || input.files.length === 0) {
      return;
    }

    const file = input.files[0];

    // Validate file type
    const validation = this.storageService.validateImageFile(file);
    if (!validation.valid) {
      this.errorMessage = validation.error || 'Invalid file';
      return;
    }

    // Validate image dimensions
    const dimensionCheck = await this.mediaService.validateImageDimensions(
      file,
      MEDIA_VALIDATION.MIN_WIDTH,
      MEDIA_VALIDATION.MIN_HEIGHT
    );

    if (!dimensionCheck.valid) {
      this.errorMessage = dimensionCheck.error || `Image must be at least ${MEDIA_VALIDATION.MIN_WIDTH}x${MEDIA_VALIDATION.MIN_HEIGHT}px`;
      return;
    }

    this.selectedCoverFile = file;
    this.errorMessage = '';

    if (this.coverPreview && this.coverPreview.startsWith('blob:')) {
      URL.revokeObjectURL(this.coverPreview);
    }

    this.coverPreview = URL.createObjectURL(file);
    console.log(`‚úÖ Cover image selected: ${dimensionCheck.width}x${dimensionCheck.height}px`);
  }

  onGalleryFilesSelected(event: Event) {
    const input = event.target as HTMLInputElement;
    if (!input.files || input.files.length === 0) {
      return;
    }

    const files = Array.from(input.files);
    const accepted: File[] = [];

    for (const file of files) {
      const validation = this.storageService.validateImageFile(file);
      if (!validation.valid) {
        this.errorMessage = validation.error || 'Invalid file';
        continue;
      }
      accepted.push(file);
    }

    if (accepted.length) {
      this.galleryFiles = [...this.galleryFiles, ...accepted];
      this.errorMessage = '';
    }
  }

  removeGalleryFile(index: number) {
    if (index < 0 || index >= this.galleryFiles.length) {
      return;
    }
    this.galleryFiles = this.galleryFiles.filter((_, i) => i !== index);
  }

  // Handle gallery media IDs from GalleryUploaderComponent
  onGalleryMediaIdsChange(mediaIds: string[]) {
    this.galleryMediaIds = mediaIds;
    console.log('‚úÖ Gallery media IDs updated:', mediaIds.length);
  }

  // Get current product slug for gallery uploader
  get currentProductSlug(): string {
    const formData = this.productForm.value;
    const category = this.categories.find(c => c.id === formData.categoryId);
    const grosor = category?.slug || '12mm';
    return this.getProductSlug(formData.name, grosor);
  }

  // Get current product grosor for gallery uploader
  get currentProductGrosor(): string {
    const formData = this.productForm.value;
    const category = this.categories.find(c => c.id === formData.categoryId);
    return category?.slug || '12mm';
  }

  async saveDraft() {
    await this.saveProduct('draft');
  }

  async publishProduct() {
    await this.saveProduct('published');
  }

  private async saveProduct(status: 'draft' | 'published') {
    if (this.productForm.invalid) {
      this.markFormGroupTouched(this.productForm);
      this.errorMessage = 'admin.invalid_form';
      return;
    }

    // For published products, validate all required fields
    if (status === 'published' && !this.canPublish) {
      const blockers = this.getPublishBlockers();
      this.errorMessage = `Cannot publish. Missing: ${blockers.join(', ')}`;
      return;
    }

    this.isSaving = true;
    this.errorMessage = '';
    this.uploadProgress = 0;

    try {
      const formData = this.productForm.value;
      const category = this.categories.find(c => c.id === formData.categoryId);
      const grosor = category?.slug || '12mm';

      const slug = this.getProductSlug(formData.name, grosor);

      // Check slug duplicates when creating or renaming
      if (!this.isEditMode || (this.selectedProduct && slug !== this.selectedProduct.slug)) {
        const slugExists = await this.productsService.slugExists(
          slug,
          grosor,
          this.selectedProduct?.id
        );
        if (slugExists) {
          this.errorMessage = 'admin.duplicate_slug';
          this.isSaving = false;
          return;
        }
      }

      const existingCover = this.selectedProduct?.coverImage || (this.selectedProduct as any)?.imageUrl;
      let coverImage = existingCover || '';
      if (this.selectedCoverFile) {
        coverImage = await this.uploadCoverImage(slug, grosor, existingCover);
      }

      const usage = formData.usage
        ? formData.usage.split(',').map((u: string) => u.trim()).filter((u: string) => u.length > 0)
        : [];

      const productData: any = {
        name: formData.name,
        slug,
        categoryId: formData.categoryId,
        materialId: formData.materialId,
        status,
        description: formData.description || '',
        variantMode: 'embedded',
        variants: [{
          sku: formData.sku || undefined,
          finish: formData.finish || 'Pulido',
          price: formData.price ? parseFloat(formData.price) : null,
          stock: formData.stock ? parseInt(formData.stock) : 0,
          active: status === 'published'
        }],
        coverImage,
        galleryImageIds: this.galleryMediaIds.length > 0 ? this.galleryMediaIds : (this.selectedProduct?.galleryImageIds || []),
        specs: {
          grosor,
          size: formData.size,
          finish: formData.finish,
          thicknessMm: category?.defaultSpecOverrides?.thicknessMm,
          usage
        },
        seo: {
          title: formData.seoTitle || '',
          metaDescription: formData.seoMeta || '',
          ogImage: coverImage || undefined
        },
        tags: this.autoFillPreview?.tags || this.selectedProduct?.tags || [],
        descriptionLocked: this.descriptionLocked,
        specsLocked: this.specsLocked,
        seoLocked: this.seoLocked,
        // Compatibility fields
        grosor,
        size: formData.size,
        imageUrl: coverImage,
        price: formData.price ? parseFloat(formData.price) : undefined,
        stock: formData.stock ? parseInt(formData.stock) : undefined,
        sku: formData.sku || undefined,
        active: status === 'published'
      };

      if (this.isEditMode && this.selectedProduct?.id) {
        await this.productsService.updateProduct(this.selectedProduct.id, productData);
        
        // Update media with product reference if cover was uploaded
        if (coverImage && coverImage !== existingCover) {
          await this.mediaService.addEntityReference(coverImage, 'product', this.selectedProduct.id);
        }
        
        this.successMessage = status === 'published' ? 'admin.product_published' : 'admin.saved_successfully';
        this.currentStatus = status;
      } else {
        const productId = await this.productsService.addProduct(productData);
        
        // Update media with product reference if cover was uploaded
        if (coverImage && productId) {
          await this.mediaService.addEntityReference(coverImage, 'product', productId);
        }
        
        this.successMessage = status === 'published' ? 'admin.product_published' : 'admin.saved_successfully';
        this.currentStatus = status;
      }

      await this.loadProducts();
      this.closeModal();

      setTimeout(() => {
        this.successMessage = '';
      }, 3000);
    } catch (error) {
      console.error('Error saving product:', error);
      this.errorMessage = 'admin.error_occurred';
    } finally {
      this.isSaving = false;
      this.isUploading = false;
      this.uploadProgress = 0;
    }
  }

  private getProductSlug(name: string, grosor: string): string {
    const baseSlug = this.storageService.generateSlug(name);
    if (this.isEditMode && this.selectedProduct?.slug === baseSlug) {
      return baseSlug;
    }
    return baseSlug;
  }

  private async uploadCoverImage(slug: string, grosor: string, existingCover?: string | null): Promise<string> {
    if (!this.selectedCoverFile) {
      return existingCover || '';
    }

    this.isUploading = true;

    try {
      // Get current user
      const user = await this.authService.getCurrentUser();
      if (!user) {
        throw new Error('User not authenticated');
      }

      // Get image dimensions
      const dimensions = await this.mediaService.getImageDimensions(this.selectedCoverFile);

      // Delete old cover if exists
      if (this.isEditMode && existingCover) {
        try {
          await this.storageService.deleteFile(existingCover);
        } catch (error) {
          console.warn('Could not delete old image:', error);
        }
      }

      // Upload image to Storage
      const downloadURL = await new Promise<string>((resolve, reject) => {
        this.storageService.uploadProductImage(
          this.selectedCoverFile!,
          slug,
          grosor
        ).subscribe({
          next: (progress) => {
            this.uploadProgress = progress.progress;
            if (progress.downloadURL) {
              resolve(progress.downloadURL);
            }
          },
          error: (error) => {
            reject(error);
          }
        });
      });

      // Extract storage path from URL for future deletion
      const storagePath = `productos/${grosor}/${slug}/${this.selectedCoverFile.name}`;

      // Create Media document
      const mediaInput: MediaCreateInput = {
        url: downloadURL,
        filename: this.selectedCoverFile.name,
        storagePath: storagePath,
        width: dimensions.width,
        height: dimensions.height,
        size: this.selectedCoverFile.size,
        mimeType: this.selectedCoverFile.type,
        uploadedBy: user.uid,
        tags: ['cover', 'product'],
        relatedEntityType: 'product',
        relatedEntityIds: [], // Will be updated when product is saved
      };

      const mediaId = await this.mediaService.createMedia(mediaInput);
      console.log('‚úÖ Media document created:', mediaId);

      this.isUploading = false;
      this.selectedCoverFile = null;

      // Return media ID instead of URL
      return mediaId;

    } catch (error) {
      this.isUploading = false;
      console.error('‚ùå Error uploading cover image:', error);
      throw error;
    }
  }

  openDeleteConfirm(product: Product) {
    this.productToDelete = product;
    this.showDeleteConfirm = true;
  }

  closeDeleteConfirm() {
    this.showDeleteConfirm = false;
    this.productToDelete = null;
  }

  async confirmDelete() {
    if (!this.productToDelete || !this.productToDelete.id) return;

    try {
      // Delete image from storage
      if (this.productToDelete.imageUrl) {
        try {
          await this.storageService.deleteFile(this.productToDelete.imageUrl);
        } catch (error) {
          console.warn('Could not delete image:', error);
        }
      }

      // Delete product from Firestore
      await this.productsService.deleteProduct(this.productToDelete.id);
      
      this.successMessage = 'admin.deleted_successfully';
      this.closeDeleteConfirm();
      await this.loadProducts();

      setTimeout(() => {
        this.successMessage = '';
      }, 3000);
    } catch (error) {
      console.error('Error deleting product:', error);
      this.errorMessage = 'admin.error_occurred';
    }
  }

  async logout() {
    try {
      await this.authService.signOutUser();
      this.router.navigate(['/']);
    } catch (error) {
      console.error('Logout error:', error);
    }
  }

  private markFormGroupTouched(formGroup: FormGroup) {
    Object.keys(formGroup.controls).forEach(key => {
      const control = formGroup.get(key);
      control?.markAsTouched();
    });
  }

  // Form getters
  get name() { return this.productForm.get('name'); }
  get categoryId() { return this.productForm.get('categoryId'); }
  get materialId() { return this.productForm.get('materialId'); }
  get description() { return this.productForm.get('description'); }
  get seoTitle() { return this.productForm.get('seoTitle'); }
  get seoMeta() { return this.productForm.get('seoMeta'); }
  get price() { return this.productForm.get('price'); }
  get stock() { return this.productForm.get('stock'); }
  get size() { return this.productForm.get('size'); }
  get sku() { return this.productForm.get('sku'); }
  get finish() { return this.productForm.get('finish'); }
  get usage() { return this.productForm.get('usage'); }
  get active() { return this.productForm.get('active'); }
  get hasCoverImage(): boolean {
    return !!this.selectedCoverFile || !!this.coverPreview || !!this.selectedProduct?.coverImage;
  }

  canAdvance(): boolean {
    return this.isStepValid(this.currentStep);
  }

  /**
   * Check if product can be published
   * Returns true only if all required fields are present
   */
  get canPublish(): boolean {
    const formData = this.productForm.value;
    
    // Required: name (min 3 chars)
    const hasName = formData.name && formData.name.trim().length >= 3;
    
    // Required: category and material selected
    const hasCategory = !!formData.categoryId;
    const hasMaterial = !!formData.materialId;
    
    // Required: cover image (either new file selected or existing)
    const hasCover = this.hasCoverImage;
    
    // Required: at least one gallery image
    const hasGallery = this.galleryMediaIds.length > 0 || (this.selectedProduct?.galleryImageIds?.length || 0) > 0;
    
    // All validations must pass
    return hasName && hasCategory && hasMaterial && hasCover && hasGallery;
  }

  /**
   * Get list of missing requirements for publishing
   * Returns array of user-friendly messages
   */
  getPublishBlockers(): string[] {
    const blockers: string[] = [];
    const formData = this.productForm.value;
    
    if (!formData.name || formData.name.trim().length < 3) {
      blockers.push('Product name (minimum 3 characters)');
    }
    
    if (!formData.categoryId) {
      blockers.push('Category selection');
    }
    
    if (!formData.materialId) {
      blockers.push('Material selection');
    }
    
    if (!this.hasCoverImage) {
      blockers.push('Cover image');
    }
    
    const hasGallery = this.galleryMediaIds.length > 0 || (this.selectedProduct?.galleryImageIds?.length || 0) > 0;
    if (!hasGallery) {
      blockers.push('At least one gallery image');
    }
    
    return blockers;
  }
}
